<!DOCTYPE html>
<html lang="pt-BR">
<!-- Previous head section remains the same until the style tag -->
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Greedy Best First Search - Visualização Interativa</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <style>
        /* Previous base styles remain the same */
        :root {
            --primary: #2563eb;
            --secondary: #4338ca;
            --accent: #f59e0b;
            --background: #0f172a;
            --text: #f8fafc;
            --success: #22c55e;
            --panel-bg: rgba(15, 23, 42, 0.9);
        }

        /* Previous styles until .content remain the same */
        body {
            margin: 0;
            padding: 0;
            background-color: var(--background);
            color: var(--text);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            min-height: 100vh;
            overflow-x: hidden;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 2rem;
            position: relative;
        }

        .header {
            text-align: center;
            margin-bottom: 4rem;
            opacity: 0;
        }

        .title {
            font-size: 3.5rem;
            margin-bottom: 1rem;
            background: linear-gradient(45deg, var(--primary), var(--accent));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            filter: drop-shadow(0 0 0.5rem rgba(37, 99, 235, 0.3));
        }

        .subtitle {
            font-size: 1.5rem;
            color: #94a3b8;
            max-width: 800px;
            margin: 0 auto;
        }

        .content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 2rem;
            margin-bottom: 4rem;
            opacity: 0;
            position: relative;
        }

        /* Updated and new styles */
        .control-dock {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: var(--panel-bg);
            backdrop-filter: blur(10px);
            padding: 1rem;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 2rem;
            transform: translateY(100%);
            transition: transform 0.3s ease;
            z-index: 100;
            box-shadow: 0 -4px 6px -1px rgba(0, 0, 0, 0.1);
        }

        .control-dock.visible {
            transform: translateY(0);
        }

        .speed-control {
            display: flex;
            align-items: center;
            gap: 1rem;
            background: rgba(255, 255, 255, 0.1);
            padding: 0.5rem 1.5rem;
            border-radius: 1rem;
            min-width: 300px;
        }

        .speed-control label {
            color: var(--text);
            font-size: 0.9rem;
            white-space: nowrap;
        }

        .speed-control input {
            width: 150px;
            accent-color: var(--accent);
        }

        .speed-value {
            min-width: 60px;
            text-align: right;
            font-family: monospace;
            font-size: 0.9rem;
        }

        .button-group {
            display: flex;
            gap: 1rem;
        }

        button {
            background: var(--primary);
            color: var(--text);
            border: none;
            padding: 0.75rem 1.5rem;
            border-radius: 0.5rem;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
            min-width: 120px;
            position: relative;
            overflow: hidden;
        }

        button::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(
                90deg,
                transparent,
                rgba(255, 255, 255, 0.2),
                transparent
            );
            transition: 0.5s;
        }

        button:hover::before {
            left: 100%;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 0.5rem 1rem rgba(37, 99, 235, 0.2);
        }

        #startBtn {
            background: var(--primary);
        }

        #resetBtn {
            background: var(--secondary);
        }

        .continue-btn {
            background: var(--success);
            display: none;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% {
                box-shadow: 0 0 0 0 rgba(34, 197, 94, 0.7);
            }
            70% {
                box-shadow: 0 0 0 10px rgba(34, 197, 94, 0);
            }
            100% {
                box-shadow: 0 0 0 0 rgba(34, 197, 94, 0);
            }
        }

        /* Previous maze-related styles remain the same */
        .maze-container {
            position: relative;
            aspect-ratio: 1;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 1rem;
            overflow: hidden;
            box-shadow: 0 0 2rem rgba(37, 99, 235, 0.2);
        }

        #maze {
            width: 100%;
            height: 100%;
        }

        .cell {
            fill: none;
            stroke: var(--primary);
            stroke-width: 2;
            transition: fill 0.3s ease;
        }

        .wall {
            fill: var(--secondary);
        }

        .start {
            fill: #22c55e;
        }

        .end {
            fill: #dc2626;
        }

        .path {
            fill: var(--accent);
        }

        .visited {
            fill: rgba(37, 99, 235, 0.3);
        }

        .current {
            fill: var(--accent);
            filter: drop-shadow(0 0 0.5rem var(--accent));
        }
    </style>
</head>
<body>
    <!-- Previous particle and container divs remain the same -->
    <div class="floating-particles" id="particles"></div>
    <div class="container">
        <!-- Previous header and content sections remain the same -->
        <header class="header">
            <h1 class="title">Greedy Best First Search</h1>
            <p class="subtitle">
                Uma jornada visual pelo algoritmo de busca gulosa, onde cada passo é guiado pela promessa do caminho mais próximo ao objetivo.
            </p>
        </header>

        <div class="content">
            <div class="explanation">
                <h2>O que é Greedy Best First Search?</h2>
                <p>
                    O algoritmo Greedy Best First Search é uma estratégia de busca que sempre escolhe o caminho que parece mais promissor em direção ao objetivo, baseando-se em uma função heurística.
                </p>
                <p>
                    Diferente de outros algoritmos de busca, o GBFS:
                </p>
                <ul>
                    <li>Prioriza o caminho que parece mais próximo do objetivo</li>
                    <li>Não considera o custo do caminho percorrido</li>
                    <li>Pode não encontrar o caminho mais curto</li>
                    <li>É mais rápido que buscas extensivas como BFS</li>
                </ul>
                <p>
                    No labirinto ao lado, o algoritmo usa a distância Manhattan até o objetivo como heurística para decidir qual será o próximo movimento.
                </p>
            </div>
            <div class="maze-container">
                <svg id="maze" viewBox="0 0 500 500"></svg>
            </div>
        </div>
    </div>

    <!-- New control dock -->
    <div class="control-dock">
        <div class="speed-control">
            <label for="speedControl">Velocidade:</label>
            <input type="range" id="speedControl" min="10" max="1000" value="100" step="10">
            <span id="speedValue" class="speed-value">100ms</span>
        </div>
        <div class="button-group">
            <button id="startBtn">Iniciar Busca</button>
            <button id="resetBtn">Resetar</button>
            <button id="continueBtn" class="continue-btn" onclick="window.location.href='Lesson1_6.html'">
                Continuar Aula
            </button>
        </div>
    </div>

    <script>
        // Previous particle creation and GSAP animation code remains the same
        const particles = document.getElementById('particles');
        for (let i = 0; i < 50; i++) {
            const particle = document.createElement('div');
            particle.className = 'particle';
            particle.style.left = `${Math.random() * 100}%`;
            particle.style.top = `${Math.random() * 100}%`;
            particle.style.animationDelay = `${Math.random() * 8}s`;
            particles.appendChild(particle);
        }

        // Initialize GSAP animations
        gsap.to('.header', {
            opacity: 1,
            duration: 1,
            ease: 'power2.out',
            y: 20,
        });

        gsap.to('.content', {
            opacity: 1,
            duration: 1,
            delay: 0.5,
            ease: 'power2.out',
            y: 20,
        });

        // Show control dock after content appears
        gsap.to('.control-dock', {
            delay: 1,
            duration: 0.5,
            ease: 'power2.out',
            className: '+=visible'
        });

        // Speed control setup
        const speedControl = document.getElementById('speedControl');
        const speedValue = document.getElementById('speedValue');
        const continueBtn = document.getElementById('continueBtn');
        let isRunning = false;
        
        speedControl.addEventListener('input', () => {
            speedValue.textContent = `${speedControl.value}ms`;
        });

        // Maze generation and pathfinding logic
        class Cell {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.isWall = Math.random() < 0.3;
                this.isVisited = false;
                this.isPath = false;
                this.element = null;
            }
        }

        class Maze {
            constructor() {
                this.grid = [];
                this.start = { x: 1, y: 1 };
                this.end = { x: MAZE_SIZE - 2, y: MAZE_SIZE - 2 };
                this.currentCell = null;
                this.initializeMaze();
            }

            initializeMaze() {
                this.grid = [];
                for (let y = 0; y < MAZE_SIZE; y++) {
                    const row = [];
                    for (let x = 0; x < MAZE_SIZE; x++) {
                        row.push(new Cell(x, y));
                    }
                    this.grid.push(row);
                }

                // Ensure start and end are not walls
                this.grid[this.start.y][this.start.x].isWall = false;
                this.grid[this.end.y][this.end.x].isWall = false;
            }

            // Previous maze methods remain the same
            manhattanDistance(from, to) {
                return Math.abs(from.x - to.x) + Math.abs(from.y - to.y);
            }

            getNeighbors(cell) {
                const neighbors = [];
                const directions = [
                    { x: 0, y: -1 }, // up
                    { x: 1, y: 0 },  // right
                    { x: 0, y: 1 },  // down
                    { x: -1, y: 0 }  // left
                ];

                for (const dir of directions) {
                    const newX = cell.x + dir.x;
                    const newY = cell.y + dir.y;

                    if (newX >= 0 && newX < MAZE_SIZE && 
                        newY >= 0 && newY < MAZE_SIZE && 
                        !this.grid[newY][newX].isWall &&
                        !this.grid[newY][newX].isVisited) {
                        neighbors.push(this.grid[newY][newX]);
                    }
                }

                return neighbors;
            }

            async findPath() {
                if (isRunning) return;
                isRunning = true;
                
                const openSet = [this.grid[this.start.y][this.start.x]];
                const path = new Map();

                while (openSet.length > 0 && isRunning) {
                    openSet.sort((a, b) => {
                        return this.manhattanDistance(a, this.end) - 
                               this.manhattanDistance(b, this.end);
                    });

                    const current = openSet.shift();
                    if (current.x === this.end.x && current.y === this.end.y) {
                        // Show continue button with animation
                        continueBtn.style.display = 'block';
                        gsap.from(continueBtn, {
                            scale: 0,
                            opacity: 0,
                            duration: 0.5,
                            ease: 'back.out'
                        });
                        isRunning = false;
                        return true;
                    }

                    current.isVisited = true;
                    this.currentCell = current;
                    current.element.classList.add('visited');
                    current.element.classList.add('current');

                    await new Promise(resolve => setTimeout(resolve, parseInt(speedControl.value)));
                    current.element.classList.remove('current');

                    const neighbors = this.getNeighbors(current);
                    for (const neighbor of neighbors) {
                        openSet.push(neighbor);
                        path.set(neighbor, current);
                    }
                }

                isRunning = false;
                return false;
            }
        }

        // UI Setup and Control
        const MAZE_SIZE = 15;
        const CELL_SIZE = 500 / MAZE_SIZE;
        let maze = new Maze();
        const svg = document.getElementById('maze');

        function drawMaze() {
            svg.innerHTML = '';
            for (let y = 0; y < MAZE_SIZE; y++) {
                for (let x = 0; x < MAZE_SIZE; x++) {
                    const cell = maze.grid[y][x];
                    const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                    rect.setAttribute('x', x * CELL_SIZE);
                    rect.setAttribute('y', y * CELL_SIZE);
                    rect.setAttribute('width', CELL_SIZE);
                    rect.setAttribute('height', CELL_SIZE);
                    rect.classList.add('cell');

                    if (cell.isWall) {
                        rect.classList.add('wall');
                    }
                    if (x === maze.start.x && y === maze.start.y) {
                        rect.classList.add('start');
                    }
                    if (x === maze.end.x && y === maze.end.y) {
                        rect.classList.add('end');
                    }

                    cell.element = rect;
                    svg.appendChild(rect);
                }
            }
        }

        // Enhanced control functionality
        document.getElementById('startBtn').addEventListener('click', async () => {
            if (!isRunning) {
                const startBtn = document.getElementById('startBtn');
                startBtn.disabled = true;
                startBtn.style.opacity = '0.5';
                const found = await maze.findPath();
                if (!found && !isRunning) {
                    alert('Não foi possível encontrar um caminho!');
                }
                startBtn.disabled = false;
                startBtn.style.opacity = '1';
            }
        });

        document.getElementById('resetBtn').addEventListener('click', () => {
            // Stop current execution
            isRunning = false;
            
            // Create new maze instance
            maze = new Maze();
            drawMaze();
            
            // Reset UI elements
            continueBtn.style.display = 'none';
            const startBtn = document.getElementById('startBtn');
            startBtn.disabled = false;
            startBtn.style.opacity = '1';
            
            // Add reset animation
            gsap.from(svg, {
                opacity: 0,
                scale: 0.95,
                duration: 0.5,
                ease: 'power2.out'
            });
        });

        // Initial draw
        drawMaze();
    </script>
</body>
</html>
