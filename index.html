<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <title>BFS Explorer - Lição 1.3</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/gsap.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', sans-serif;
        }

        body {
            background: #000;
            color: #fff;
            overflow: hidden;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        #gameContainer {
            position: relative;
            flex-grow: 1;
            background: linear-gradient(45deg, #000428, #004e92);
        }

        canvas {
            position: absolute;
            top: 0;
            left: 0;
        }

        #hud {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }

        .panel {
            position: absolute;
            background: rgba(0, 30, 60, 0.85);
            border: 2px solid #00f7ff;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 0 20px #00f7ff33;
            backdrop-filter: blur(10px);
        }

        #controlPanel {
            right: 20px;
            top: 20px;
            width: 300px;
            pointer-events: all;
        }

        #infoPanel {
            left: 20px;
            bottom: 20px;
            width: 400px;
        }

        .neon-button {
            background: rgba(0, 247, 255, 0.1);
            border: 2px solid #00f7ff;
            color: #fff;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s;
            text-transform: uppercase;
            letter-spacing: 2px;
            margin: 5px 0;
            pointer-events: all;
            width: 100%;
        }

        .neon-button:hover {
            background: rgba(0, 247, 255, 0.2);
            box-shadow: 0 0 20px #00f7ff;
        }

        .stat {
            display: flex;
            justify-content: space-between;
            margin: 10px 0;
            font-size: 0.9em;
            color: #00f7ff;
        }

        #nextLessonButton {
            position: absolute;
            bottom: 20px;
            right: 20px;
            opacity: 0;
            pointer-events: none;
        }

        #nextLessonButton.visible {
            opacity: 1;
            pointer-events: all;
        }

        .progress-bar {
            width: 100%;
            height: 4px;
            background: rgba(0, 247, 255, 0.1);
            border-radius: 2px;
            margin-top: 5px;
        }

        .progress-fill {
            height: 100%;
            background: #00f7ff;
            border-radius: 2px;
            width: 0%;
            transition: width 0.3s;
        }

        #tutorial {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            font-size: 1.5em;
            text-shadow: 0 0 10px #00f7ff;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <div id="hud">
            <div id="tutorial">
                Pressione INICIAR para começar a exploração
            </div>
            <div id="controlPanel" class="panel">
                <h2 style="margin-bottom: 15px; color: #00f7ff">Controles de Exploração</h2>
                <button class="neon-button" id="startButton">Iniciar</button>
                <button class="neon-button" id="pauseButton" disabled>Pausar</button>
                <div class="stat">
                    <span>Velocidade de Exploração</span>
                    <span id="speedValue">1x</span>
                </div>
                <input type="range" id="speedSlider" min="1" max="5" value="1" style="width: 100%">
                <div class="stat">
                    <span>Nós Explorados</span>
                    <span id="nodesExplored">0</span>
                </div>
                <div class="stat">
                    <span>Profundidade</span>
                    <span id="currentDepth">0</span>
                </div>
                <div class="stat">
                    <span>Progresso</span>
                    <span id="progressPercent">0%</span>
                </div>
                <div class="progress-bar">
                    <div class="progress-fill" id="progressBar"></div>
                </div>
            </div>
            <div id="infoPanel" class="panel">
                <h2 style="margin-bottom: 15px; color: #00f7ff">Busca em Largura (BFS)</h2>
                <p style="line-height: 1.6">
                    A Busca em Largura explora todos os nós vizinhos no mesmo nível antes de
                    avançar para o próximo nível. Este algoritmo garante o caminho mais curto
                    em termos de número de passos.
                </p>
            </div>
            <button id="nextLessonButton" class="neon-button">
                Continuar para Lição 1.4
            </button>
        </div>
    </div>
    <script>
        // Three.js setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.getElementById('gameContainer').appendChild(renderer.domElement);

        // Grid configuration
        const GRID_SIZE = 15;
        const SPACING = 2;
        const nodes = [];
        const edges = [];
        let currentLevel = 0;
        let visitedNodes = new Set();
        let queue = [];
        let isRunning = false;
        let isPaused = false;
        
        // Material definitions
        const nodeMaterial = new THREE.MeshPhongMaterial({ color: 0x00ff00 });
        const visitedMaterial = new THREE.MeshPhongMaterial({ color: 0x00f7ff });
        const currentMaterial = new THREE.MeshPhongMaterial({ color: 0xff0000 });
        const edgeMaterial = new THREE.LineBasicMaterial({ color: 0x00f7ff, transparent: true, opacity: 0.3 });

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);
        const pointLight = new THREE.PointLight(0x00f7ff, 1);
        pointLight.position.set(10, 10, 10);
        scene.add(pointLight);

        // Camera positioning
        camera.position.set(GRID_SIZE * SPACING, GRID_SIZE * SPACING, GRID_SIZE * SPACING);
        camera.lookAt(0, 0, 0);

        // Create grid
        for (let x = 0; x < GRID_SIZE; x++) {
            for (let y = 0; y < GRID_SIZE; y++) {
                for (let z = 0; z < GRID_SIZE; z++) {
                    if (Math.random() > 0.8) {
                        const geometry = new THREE.SphereGeometry(0.2, 32, 32);
                        const node = new THREE.Mesh(geometry, nodeMaterial);
                        node.position.set(
                            x * SPACING - (GRID_SIZE * SPACING) / 2,
                            y * SPACING - (GRID_SIZE * SPACING) / 2,
                            z * SPACING - (GRID_SIZE * SPACING) / 2
                        );
                        node.userData = { x, y, z, visited: false };
                        scene.add(node);
                        nodes.push(node);
                    }
                }
            }
        }

        // Create edges between nearby nodes
        nodes.forEach(node1 => {
            nodes.forEach(node2 => {
                if (node1 !== node2) {
                    const distance = node1.position.distanceTo(node2.position);
                    if (distance < SPACING * 1.5) {
                        const geometry = new THREE.BufferGeometry().setFromPoints([
                            node1.position,
                            node2.position
                        ]);
                        const line = new THREE.Line(geometry, edgeMaterial);
                        scene.add(line);
                        edges.push(line);
                    }
                }
            });
        });

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            
            // Rotate camera
            if (!isPaused) {
                camera.position.x = GRID_SIZE * SPACING * Math.cos(Date.now() * 0.0001);
                camera.position.z = GRID_SIZE * SPACING * Math.sin(Date.now() * 0.0001);
                camera.lookAt(0, 0, 0);
            }

            // Pulse effect for nodes
            nodes.forEach(node => {
                const scale = 1 + Math.sin(Date.now() * 0.003) * 0.1;
                node.scale.set(scale, scale, scale);
            });

            renderer.render(scene, camera);
        }

        // BFS implementation
        async function bfs() {
            if (nodes.length === 0) return;
            
            const startNode = nodes[0];
            queue = [startNode];
            startNode.userData.visited = true;
            
            while (queue.length > 0 && isRunning && !isPaused) {
                const current = queue.shift();
                current.material = currentMaterial;
                
                // Update stats
                document.getElementById('nodesExplored').textContent = visitedNodes.size;
                document.getElementById('currentDepth').textContent = currentLevel;
                const progress = (visitedNodes.size / nodes.length * 100).toFixed(1);
                document.getElementById('progressPercent').textContent = `${progress}%`;
                document.getElementById('progressBar').style.width = `${progress}%`;

                // Find neighbors
                const neighbors = nodes.filter(node => {
                    const distance = node.position.distanceTo(current.position);
                    return distance < SPACING * 1.5 && !node.userData.visited;
                });

                for (const neighbor of neighbors) {
                    neighbor.userData.visited = true;
                    visitedNodes.add(neighbor);
                    queue.push(neighbor);
                    
                    // Animate neighbor discovery
                    gsap.to(neighbor.material.color, {
                        r: visitedMaterial.color.r,
                        g: visitedMaterial.color.g,
                        b: visitedMaterial.color.b,
                        duration: 0.5
                    });
                }

                current.material = visitedMaterial;
                
                // Delay based on speed slider
                const speed = document.getElementById('speedSlider').value;
                await new Promise(resolve => setTimeout(resolve, 1000 / speed));
            }

            if (visitedNodes.size === nodes.length) {
                document.getElementById('nextLessonButton').classList.add('visible');
            }
        }

        // Event listeners
        document.getElementById('startButton').addEventListener('click', () => {
            isRunning = true;
            isPaused = false;
            document.getElementById('startButton').disabled = true;
            document.getElementById('pauseButton').disabled = false;
            document.getElementById('tutorial').style.display = 'none';
            bfs();
        });

        document.getElementById('pauseButton').addEventListener('click', () => {
            isPaused = !isPaused;
            document.getElementById('pauseButton').textContent = isPaused ? 'Continuar' : 'Pausar';
        });

        document.getElementById('speedSlider').addEventListener('input', (e) => {
            document.getElementById('speedValue').textContent = `${e.target.value}x`;
        });

        document.getElementById('nextLessonButton').addEventListener('click', () => {
            window.location.href = 'Lesson1_4.html';
        });

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Start animation loop
        animate();
    </script>
</body>
</html>
